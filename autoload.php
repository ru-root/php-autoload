<?php /*﻿*/ declare(strict_types=1);
/*
 * @license https://opensource.org/licenses/MIT  MIT License
 * The MIT License (MIT)
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Simple Recursive Autoloader
 * A simple autoloader that loads class files recursively starting in the directory
 * where this class resides.  Additional options can be provided to control the naming
 * convention of the class files.
 */
// namespace Ruroot;
 /**
  * @example:
  * <?php
  *    (require __DIR__ .DIRECTORY_SEPARATOR .'vendor' .DIRECTORY_SEPARATOR .'autoload.php')
  *        // ->setApcu('APP_NAME')
  *        ->setCacheKey('CacheKeyName')
  *        ->logger(false) // FALSE Display error, (TRUE or empty) Log error
  *        ->setPaths([
  *            __DIR__ .DIRECTORY_SEPARATOR .'classes',
  *            __DIR__ .DIRECTORY_SEPARATOR .'vendor',
  *            APP_PATH .'classes',
  *            APP_PATH .'vendor',
  *        ])->includes([
  *            'functions',
  *            'FastRoute\functions',
  *            'bootstrap'
  *        ]);
  *
  *     Autoloader::include('settings', 'config');
  */
class Autoloader
{
    public const EXT = '.php';
    public const ERROR_FILE = __DIR__ .DIRECTORY_SEPARATOR .'..' .DIRECTORY_SEPARATOR .'php_autoload.log';
    public const ERROR_STR_LOG = 'PHP %s: %s in %s on line %s';
    public const ERROR_STR_DSP = 'PHP %s: %s - See logs!';
    public const ERROR_TYPE    = [
        1    => 'Error',
        4    => 'Parse',
        256  => 'Error',
        2    => 'Warning',
        8    => 'Notice',
        2048 => 'Strict',
        8192 => 'Deprecated',
        4096 => 'Recoverable',
    ];

    private static $anonymous;

    /**
     * Registers this instance as an autoloader.
     * @param bool|int|string $log dir path or code E_ALL ^ E_WARNING ... or FALSE off error
     * Silence E_ALL ^ E_WARNING to ignore "include" failures - don't use "@" to prevent silencing fatal errors!
     */
    final public static function register()
    {
        if ( ! self::$anonymous) {
            self::$anonymous = new class
            {
                private static int $cacheTTL = 86400; // 24h
                private static string $cacheFile = __DIR__ .DIRECTORY_SEPARATOR .'autoload_cache' .Autoloader::EXT;
                private static string $cacheFileStr = '<?php /*﻿ Generated by Autoloader::class */ return %s;';
                private static array $paths = [];
                private static array $files = [];
                private static bool $found = FALSE;
                private static ?string $apcu = NULL;

                public static ?\Closure $include = NULL;

                final public function __construct()
                {
                    $this->register();
                }

                /** Finds the path to the file where the class is defined. **/
                final public static function findFile(string $dir, string $file, string $ext = Autoloader::EXT): string|FALSE
                {
                    $file = ltrim($dir .DIRECTORY_SEPARATOR, '/\\') .$file .$ext;
                    if (isset(self::$files[$file]))
                        return self::$files[$file];
                    elseif (self::$apcu && apcu_exists(self::$apcu .$file)) {
                        return apcu_fetch(self::$apcu .$file);
                    }

                    $found = FALSE;
                    foreach (self::$paths as $_) {
                        if (is_file($_ .$file)) {
                            $found = self::$files[$file] = $_ .$file;
                            // Remember that this class.
                            if ( ! (self::$found = is_null(self::$apcu))) {
                                apcu_store(self::$apcu .$file, $found, self::$cacheTTL);
                            }
                            break;
                        }
                    }

                    if ( ! $found) {
                        // Unset that this class does not exist.
                        (self::$found = is_null(self::$apcu)) || apcu_delete(self::$apcu .$file);
                        unset(self::$files[$file]);
                    }
                    return $found;
                }

                final public static function cache(array $data = NULL): array
                {
                    if (is_null($data)) {
                        if (is_file(self::$cacheFile)) {
                            if ((time() - filemtime(self::$cacheFile)) < self::$cacheTTL) {
                                return (self::$include)(self::$cacheFile);
                            }
                            self::clearCache();
                        }
                        $data = [];
                    } elseif (is_writable(__DIR__)) {
                        // This a local static variable to avoid instantiating a closure each time we need an empty handler
                        //set_error_handler(static function (): void {});
                        file_put_contents(self::$cacheFile, sprintf(self::$cacheFileStr, var_export($data, TRUE)), LOCK_EX);
                        //restore_error_handler();
                    }
                    return $data;
                }

                final public static function clearCache(): void
                {
                    //set_error_handler(static function (): void {});
                    unlink(self::$cacheFile);
                    //restore_error_handler();
                    is_null(self::$apcu) || apcu_clear_cache();
                }

                final public function logger(bool|int|string $log = TRUE): self
                {
                    static $static;
                    if ( ! isset($static) || $static !== $log) {
                        error_reporting((is_int($log) ? $log : E_ALL));
                        ini_set('html_errors', '0');
                        ini_set('log_errors',             $log ? '1' : '0');
                        ini_set('display_errors',         $log ? '0' : '1');
                        ini_set('display_startup_errors', $log ? '0' : '1');
                        ! ($static = $log)
                            || ini_set('error_log', (is_string($log) ? $log : Autoloader::ERROR_FILE));
                    }
                    return $this;
                }

                private function register(): self
                {
                    if ( ! self::$include) {

                        /** Scope isolated include. Prevents access to $this/self from included files. **/
                        self::$include = static function(string $_): mixed {
                            return include $_;
                        };

                        /** Loads the given class or interface. **/
                        // spl_autoload_extensions(Autoloader::EXT);
                        spl_autoload_register(static function (string $class): bool {
                            // PSR-0 and PEAR-like class name lookup
                            return ($class = self::findFile('', str_replace(['\\', '_'], DIRECTORY_SEPARATOR, ltrim($class, '\\'))))
                                ? (bool) (self::$include)($class)
                                : FALSE;
                        });

                        register_shutdown_function(static function(): void {
                            // Remember
                            ! is_null(self::$apcu) || FALSE === self::$found || self::cache(self::$files);
                            // Error message
                            if ($message = Autoloader::registerShutdownErrorLast()) {
                                self::clearCache();
                                exit($message);
                            }
                        });

                        self::$apcu || self::$files = self::cache();
                    }
                    return $this;
                }

                /** Unregisters this instance. **/
                final public function unregister(): self
                {
                    if ( ! is_null(self::$include)) {
                        spl_autoload_unregister(spl_autoload_functions()[0]);
                        ! self::$apcu || apcu_clear_cache();
                        self::clearCache();
                        self::$include = self::$apcu = NULL;
                        self::$files = [];
                    }
                    return $this;
                }

                /** APCu prefix to use to cache found/not-found classes, if the extension is enabled. **/
                final public function setApcu(string $apcu): self
                {
                    if (function_exists('apcu_enabled') && apcu_enabled()) {
                        self::$apcu = $apcu;
                    }
                    return $this;
                }

                final public function setCacheKey(?string $cacheKey = NULL, string $path = ''): self
                {
                    self::$cacheFile = (is_writable($path)
                        ? rtrim($path, '\\/')
                        : __DIR__) .DIRECTORY_SEPARATOR .'_' .$cacheKey .'_autoload_cache' .Autoloader::EXT;
                    return $this;
                }

                final public function setPaths(array $paths): self
                {
                    foreach ($paths as $paths) /** FIFO **/ {
                        in_array($paths = rtrim($paths, '/\\') .DIRECTORY_SEPARATOR, self::$paths, TRUE)
                            || array_unshift(self::$paths, $paths);
                    }
                    return $this;
                }

                final public function includes(array $files, string $dir = ''): self
                {
                    foreach ($files as $file) {
                        ! is_file($file) && ! ($file = self::findFile(strtr($dir, '\\', DIRECTORY_SEPARATOR), $file))
                            || (self::$include)($file);
                    }
                    return $this;
                }
            };
        }
        return self::$anonymous;
    }

    public static function findFile(string $dir, string $file, string $ext = self::EXT): string|FALSE
    {
        return self::$anonymous::findFile(strtr($dir, '\\', DIRECTORY_SEPARATOR), $file, $ext);
    }

    public static function include(string $file, string $dir = '', string $ext = self::EXT): mixed
    {
        return is_file($file) || ($file = self::findFile($dir, $file, $ext))
            ? (self::$anonymous::$include)($file)
            : NULL;
    }

    final public static function registerShutdownErrorLast(): string|int
    {
        $message = 0;
        if ($err = error_get_last()) {
            $err['type'] = self::ERROR_TYPE[$err['type']] ?? 'Unknown';
            if ( ! $message = (int) filter_var(ini_get('display_errors'), FILTER_VALIDATE_BOOLEAN)) {
                $message = sprintf(self::ERROR_STR_DSP, $err['type'], $err['message']);
            }

            if ( ! $message || error_reporting() !== E_ALL) {
                error_log(sprintf(self::ERROR_STR_LOG,
                            $err['type'],
                            $err['message'],
                            $err['file'],
                            $err['line']
                ));
            }

            if (in_array($err['type'], [E_PARSE, E_ERROR, E_USER_ERROR])) {
                $message = 1;
                ob_get_level() && ob_clean();
            }
        }

        return $message;
    }
}

return Autoloader::register();
// EOF

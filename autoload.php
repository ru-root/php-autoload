<?php /*﻿*/ declare(strict_types=1);
/*
 * @package ArrayMap
 * @license https://opensource.org/licenses/MIT  MIT License
 * The MIT License (MIT)
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Simple Recursive Autoloader
 * A simple autoloader that loads class files recursively starting in the directory
 * where this class resides.  Additional options can be provided to control the naming
 * convention of the class files.
 *
 * @example:
 * <?php
 *     Autoloader::logger(FALSE); // Enable display error
 *     Autoloader::setPath(['/path/dir', '/path/appName']); // auto register()
 *     Autoloader::include('/path/appName/bootstrap.php');
 *    // Autoloader::register();
 *  // VS
 *     spl_autoload_register('Autoloader::loadClass', TRUE, FALSE);
 */
abstract class Autoloader {

    public const EXT = '.php';

    private const CACHE_TTL  = 86400; // 24h
    private const CACHE_FILE = __DIR__ .DIRECTORY_SEPARATOR .'autoload_cache' .self::EXT;
    private const REGISTER   = [__CLASS__, 'loadClass'];

    private static array $pathsMap = [];
    private static array $filesMap = [];
    private static bool   $foundFile = FALSE;
    private static ?Closure $include = NULL;
    private static ?string  $apcuPrefix  = NULL;


    /** Loads the given class or interface. **/
    public static function loadClass(string $class): bool
    {
        // PSR-0 PSR-4 and PEAR-like class name lookup
        $class = str_replace(['\\', '_'], DIRECTORY_SEPARATOR, ltrim($class, '\\'));
        return ($file = self::findFile('', $class))
            ? (bool) (self::$include)($file)
            : FALSE;
    }


    /** Finds the path to the file where the class is defined. **/
    public static function findFile(string $dir, string $file, string $ext = self::EXT): string|FALSE
    {
        $file = ltrim($dir .DIRECTORY_SEPARATOR, '/\\') .$file .$ext;
        if (isset(self::$filesMap[$file]))
            return self::$filesMap[$file];
        elseif ( ! is_null(self::$apcuPrefix)) {
            $file = apcu_fetch(self::$apcuPrefix .$file, $found);
            if ($found) return $file;
        }

        $found = FALSE;
        foreach (self::$pathsMap as & $_) {
            if (is_file($_ .$file)) {
                $found = self::$filesMap[$file] = $_ .$file;
                // Remember that this class.
                self::$foundFile = is_null(self::$apcuPrefix)
                    || apcu_add(self::$apcuPrefix .$file, $found, self::CACHE_TTL);
                break;
            }
        }

        if ( ! $found) {
            // Unset that this class does not exist.
            self::$foundFile = is_null(self::$apcuPrefix) || apcu_delete(self::$apcuPrefix .$file);
            unset(self::$filesMap[$file]);
        }

        return $found;
    }


    public static function cache(array $data = NULL): array
    {
        if (is_null($data)) {
           if (is_file(self::CACHE_FILE)) {
               if ((time() - filemtime(self::CACHE_FILE)) < self::CACHE_TTL) {
                   return (self::$include)(self::CACHE_FILE);
               }
               self::clearCache();
           }
           $data = [];
        } else {
           // This a local static variable to avoid instantiating a closure each time we need an empty handler
           ! is_writable(__DIR__)
               || set_error_handler(static function (): void {})
               | file_put_contents(self::CACHE_FILE, /* "\xEF\xBB\xBF" */
                   '<?php /*﻿*/// Generated by ' .__CLASS__ ."::class\nreturn " .var_export($data, TRUE) .';',
                   LOCK_EX) | restore_error_handler();
        }
        return $data;
    }


    public static function clearCache(): void
    {
        set_error_handler(static function (): void {})
            | unlink(self::CACHE_FILE)
            | restore_error_handler()
            | is_null(self::$apcuPrefix) || apcu_clear_cache();
    }


    public static function logger(bool|string $log = TRUE): void
    {
        static $static;

        if ( ! isset($static) && $log || is_string($log)) {
            ini_set('log_errors',   $static = $log ? '1' : '0');
            ini_set('display_errors',         $log ? '0' : '1');
            ini_set('display_startup_errors', $log ? '0' : '1');
            ! $log || ini_set('error_log', (is_string($log) ? $log : dirname(__DIR__) .DIRECTORY_SEPARATOR) .'php_error.log');
        }
    }


    /**
     * Registers this instance as an autoloader.
     * @param bool $prepend Whether to prepend the autoloader or not
     */
    public static function register(bool $prepend = FALSE): void
    {
        if (is_null(self::$include)) {

            // Silence E_WARNING to ignore "include" failures - don't use "@" to prevent silencing fatal errors
            error_reporting(E_ALL /* E_ALL ^ E_WARNING */);

            self::$pathsMap = [dirname(__DIR__) .DIRECTORY_SEPARATOR];

            /** Scope isolated include. Prevents access to $this/self from included files. **/
            self::$include = static function(string $_): mixed {
                return include $_;
            };

            spl_autoload_register(self::REGISTER, TRUE, $prepend);

            register_shutdown_function(static function(): void {
                // Remember in file vs apcu.
                self::$apcuPrefix || FALSE === self::$foundFile || self::cache(self::$filesMap);
                if ($_ = error_get_last()) {
                    // On error write log and remove cache and buffer
                    error_log($_['type'] . ': ' .$_['message'] .' file ' .$_['file'] .' line ' .$_['line'])
                        | self::clearCache()
                        | (ob_get_level() && ob_clean())
                        | exit('Error type:' .$_['type'] .' - See logs!');
                }
            });

            self::$apcuPrefix || self::$filesMap = self::cache();
        }
    }


    /** Unregisters this instance as an autoloader. **/
    public static function unregister(): void
    {
        if ( ! is_null(self::$include)) {
            spl_autoload_unregister(self::REGISTER);
            self::$include = self::$apcuPrefix = NULL;
            self::$filesMap = [];
        }
    }


    /** 
     * APCu prefix to use to cache found/not-found classes, if the extension is enabled.
     * @see self::logger
     */
    final public static function setApcuPrefix(string $apcuPrefix): void
    {
        self::logger();
        if (function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN)) 
           self::$apcuPrefix = $apcuPrefix;
    }


    /** @see self::register **/
    final public static function setPath(array $path): void
    {
        self::register();
        foreach ($path as & $path) /** FIFO **/
              in_array($path = rtrim($path, '/\\') .DIRECTORY_SEPARATOR, self::$pathsMap, TRUE)
                  || array_unshift(self::$pathsMap, $path);
    }


    final public static function include(string $file, string $dir = ''): void
    {
       ! is_file($file) && ! ($file = self::findFile(strtr($dir, '\\', DIRECTORY_SEPARATOR), $file)) || (self::$include)($file);
    }
}

Autoloader::logger();
// EOF
